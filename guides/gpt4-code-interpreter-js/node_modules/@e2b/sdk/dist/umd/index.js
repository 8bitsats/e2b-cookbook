(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('cross-fetch/polyfill'), require('openapi-typescript-fetch'), require('platform'), require('normalize-path'), require('rpc-websocket-client')) :
  typeof define === 'function' && define.amd ? define(['exports', 'cross-fetch/polyfill', 'openapi-typescript-fetch', 'platform', 'normalize-path', 'rpc-websocket-client'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["@e2b/sdk"] = {}, null, global.openapiTypescriptFetch, global.platform, global.normalizePath, global.rpcWebsocketClient));
})(this, (function (exports, polyfill, openapiTypescriptFetch, platform, normalizePath, rpcWebsocketClient) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var platform__default = /*#__PURE__*/_interopDefaultLegacy(platform);
  var normalizePath__default = /*#__PURE__*/_interopDefaultLegacy(normalizePath);

  const SESSION_REFRESH_PERIOD = 5000; // 5s
  const WS_RECONNECT_INTERVAL = 600; // 600ms
  const TIMEOUT = 60000; // 60s
  const SESSION_DOMAIN = 'ondevbook.com';
  const WS_PORT = 49982;
  const WS_ROUTE = '/ws';

  var _a;
  const client = openapiTypescriptFetch.Fetcher.for();
  client.configure({
      baseUrl: `https://${SESSION_DOMAIN}`,
      init: {
          headers: {
              package_version: '0.4.1',
              lang: 'js',
              engine: platform__default["default"].name || 'unknown',
              lang_version: platform__default["default"].version || 'unknown',
              system: ((_a = platform__default["default"].os) === null || _a === void 0 ? void 0 : _a.family) || 'unknown',
              publisher: 'e2b',
          },
      },
  });

  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };

  function id(length) {
      let result = '';
      const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      const charactersLength = characters.length;
      for (let i = 0; i < length; i++) {
          result += characters.charAt(Math.floor(Math.random() * charactersLength));
      }
      return result;
  }

  class TimeoutError extends Error {
      constructor(message) {
          super(message);
          this.name = 'TimeoutError';
      }
  }
  class AuthenticationError extends Error {
      constructor(message) {
          super(message);
          this.name = 'AuthenticationError';
      }
  }

  function assertFulfilled(item) {
      return item.status === 'fulfilled';
  }
  function formatSettledErrors(settled) {
      if (settled.every(s => s.status === 'fulfilled'))
          return;
      return settled.reduce((prev, curr, i) => {
          if (curr.status === 'rejected') {
              return prev + '\n' + `[${i}]: ` + `${JSON.stringify(curr)}`;
          }
          return prev;
      }, 'errors:\n');
  }
  function createDeferredPromise() {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
      });
      return {
          promise,
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          reject: reject,
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          resolve: resolve,
      };
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  function withTimeout(fn, timeout = TIMEOUT) {
      if (timeout === undefined || timeout <= 0 || timeout === Number.POSITIVE_INFINITY) {
          return fn;
      }
      let timerId;
      const timer = new Promise((resolve, reject) => {
          timerId = setTimeout(() => reject(new TimeoutError(`Calling "${fn.name}" timeouted after ${timeout}ms.`)), timeout);
      });
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return ((...args) => {
          const result = Promise.race([timer, fn(...args)]);
          result.finally(() => clearTimeout(timerId));
          return result;
      });
  }

  const codeSnippetService = 'codeSnippet';

  const filesystemService = 'filesystem';

  exports.FilesystemOperation = void 0;
  (function (FilesystemOperation) {
      FilesystemOperation["Create"] = "Create";
      FilesystemOperation["Write"] = "Write";
      FilesystemOperation["Remove"] = "Remove";
      FilesystemOperation["Rename"] = "Rename";
      FilesystemOperation["Chmod"] = "Chmod";
  })(exports.FilesystemOperation || (exports.FilesystemOperation = {}));
  class FilesystemWatcher {
      constructor(sessConn, path) {
          this.sessConn = sessConn;
          this.path = path;
          this.listeners = new Set();
      }
      // Starts watching the path that was passed to the contructor
      start(opts) {
          return __awaiter(this, void 0, void 0, function* () {
              const start = () => __awaiter(this, void 0, void 0, function* () {
                  // Already started.
                  if (this.rpcSubscriptionID)
                      return;
                  this.handleFilesystemEvents = this.handleFilesystemEvents.bind(this);
                  this.rpcSubscriptionID = yield this.sessConn.subscribe(filesystemService, this.handleFilesystemEvents, 'watchDir', this.path);
              });
              return yield withTimeout(start, opts === null || opts === void 0 ? void 0 : opts.timeout)();
          });
      }
      // Stops watching the path and removes all listeners.
      stop() {
          return __awaiter(this, void 0, void 0, function* () {
              this.listeners.clear();
              if (this.rpcSubscriptionID) {
                  yield this.sessConn.unsubscribe(this.rpcSubscriptionID);
              }
          });
      }
      addEventListener(l) {
          this.listeners.add(l);
          return () => this.listeners.delete(l);
      }
      handleFilesystemEvents(fsChange) {
          this.listeners.forEach(l => {
              l(fsChange);
          });
      }
  }

  const processService = 'process';
  /**
   * A message from a process.
   */
  class ProcessMessage {
      constructor(line, 
      /**
       * Unix epoch in nanoseconds
       */
      timestamp, error) {
          this.line = line;
          this.timestamp = timestamp;
          this.error = error;
          // eslint-disable-next-line prettier/prettier
      }
  }
  /**
   * Output from a process.
   */
  class ProcessOutput {
      constructor() {
          this.delimiter = '\n';
          this.messages = [];
          this._error = false;
      }
      /**
       * Whether the process has errored.
       */
      get error() {
          return this._error;
      }
      /**
       * The stdout from the process.
       */
      get stdout() {
          return this.messages
              .filter(out => !out.error)
              .map(out => out.line)
              .join(this.delimiter);
      }
      /**
       * The stderr from the process.
       */
      get stderr() {
          return this.messages
              .filter(out => out.error)
              .map(out => out.line)
              .join(this.delimiter);
      }
      addStdout(message) {
          this.insertByTimestamp(message);
      }
      addStderr(message) {
          this._error = true;
          this.insertByTimestamp(message);
      }
      insertByTimestamp(message) {
          let i = this.messages.length - 1;
          while (i >= 0 && this.messages[i].timestamp > message.timestamp) {
              i -= 1;
          }
          this.messages.splice(i + 1, 0, message);
      }
  }
  /**
   * A process running in the environment.
   */
  class Process {
      constructor(processID, session, triggerExit, finished, output) {
          this.processID = processID;
          this.session = session;
          this.triggerExit = triggerExit;
          this.finished = finished;
          this.output = output;
      }
      /**
       * Kills the process.
       */
      kill() {
          return __awaiter(this, void 0, void 0, function* () {
              try {
                  yield this.session.call(processService, 'kill', [this.processID]);
              }
              finally {
                  this.triggerExit();
                  yield this.finished;
              }
          });
      }
      /**
       * Sends data to the process stdin.
       *
       * @param data Data to send
       * @param opts Call options
       * @param {timeout} [opts.timeout] Timeout in milliseconds (default is 60 seconds)
       */
      sendStdin(data, opts) {
          return __awaiter(this, void 0, void 0, function* () {
              yield this.session.call(processService, 'stdin', [this.processID, data], opts);
          });
      }
  }

  function wait(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
  }

  const createSession = client.path('/sessions').method('post').create({ api_key: true });
  const refreshSession = client
      .path('/sessions/{sessionID}/refresh')
      .method('post')
      .create({ api_key: true });
  class SessionConnection {
      // let's keep opts readonly, but public – for convenience, mainly when debugging
      constructor(opts) {
          var _a, _b, _c;
          this.opts = opts;
          this.isOpen = false;
          this.rpc = new rpcWebsocketClient.RpcWebSocketClient();
          this.subscribers = [];
          const apiKey = opts.apiKey || process.env.E2B_API_KEY;
          if (!apiKey) {
              throw new AuthenticationError('API key is required, please visit https://e2b.dev/docs to get your API key');
          }
          this.apiKey = apiKey;
          this.logger = (_a = opts.logger) !== null && _a !== void 0 ? _a : {
              // by default, we log to the console
              // we don't log debug messages by default
              info: console.info,
              warn: console.warn,
              error: console.error,
          };
          (_c = (_b = this.logger).info) === null || _c === void 0 ? void 0 : _c.call(_b, `Session "${opts.id}" initialized`);
      }
      /**
       * Get the hostname for the session or for the specified session's port.
       *
       * `getHostname` method requires `this` context - you may need to bind it.
       *
       * @param port Specify if you want to connect to a specific port of the session
       * @returns Hostname of the session or session's port
       */
      getHostname(port) {
          if (this.opts.__debug_hostname) {
              // Debugging remotely (with GitPod) and on local needs different formats of the hostname.
              if (port && this.opts.__debug_devEnv === 'remote') {
                  return `${port}-${this.opts.__debug_hostname}`;
              }
              else if (port) {
                  return `${this.opts.__debug_hostname}:${port}`;
              }
              else {
                  return this.opts.__debug_hostname;
              }
          }
          if (!this.session) {
              return undefined;
          }
          const hostname = `${this.session.sessionID}-${this.session.clientID}.${SESSION_DOMAIN}`;
          if (port) {
              return `${port}-${hostname}`;
          }
          else {
              return hostname;
          }
      }
      /**
       * Close the connection to the session
       *
       * `close` method requires `this` context - you may need to bind it.
       */
      close() {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
          return __awaiter(this, void 0, void 0, function* () {
              if (this.isOpen) {
                  (_b = (_a = this.logger).debug) === null || _b === void 0 ? void 0 : _b.call(_a, `Closing session "${(_c = this.session) === null || _c === void 0 ? void 0 : _c.sessionID}"`);
                  this.isOpen = false;
                  (_e = (_d = this.logger).debug) === null || _e === void 0 ? void 0 : _e.call(_d, 'Unsubscribing...');
                  const results = yield Promise.allSettled(this.subscribers.map(s => this.unsubscribe(s.subID)));
                  results.forEach(r => {
                      var _a, _b;
                      if (r.status === 'rejected') {
                          (_b = (_a = this.logger).warn) === null || _b === void 0 ? void 0 : _b.call(_a, `Failed to unsubscribe: "${r.reason}"`);
                      }
                  });
                  // This is `ws` way of closing connection
                  (_g = (_f = this.rpc.ws) === null || _f === void 0 ? void 0 : _f.terminate) === null || _g === void 0 ? void 0 : _g.call(_f);
                  // This is the browser WebSocket way of closing connection
                  (_j = (_h = this.rpc.ws) === null || _h === void 0 ? void 0 : _h.close) === null || _j === void 0 ? void 0 : _j.call(_h);
                  (_l = (_k = this.logger).info) === null || _l === void 0 ? void 0 : _l.call(_k, 'Disconnected from the session');
              }
          });
      }
      /**
       * Open a connection to a new session
       *
       * `open` method requires `this` context - you may need to bind it.
       * @param opts Call options
       * @param {timeout} [opts.timeout] Timeout in milliseconds (default is 60 seconds)
       */
      open(opts) {
          return __awaiter(this, void 0, void 0, function* () {
              const open = () => __awaiter(this, void 0, void 0, function* () {
                  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
                  if (this.isOpen || !!this.session) {
                      throw new Error('Session connect was already called');
                  }
                  else {
                      this.isOpen = true;
                  }
                  (_b = (_a = this.logger).debug) === null || _b === void 0 ? void 0 : _b.call(_a, 'Opening session...');
                  if (!this.opts.__debug_hostname) {
                      try {
                          const res = yield createSession({
                              api_key: this.apiKey,
                              codeSnippetID: this.opts.id,
                              editEnabled: false,
                          });
                          this.session = res.data;
                          (_d = (_c = this.logger).debug) === null || _d === void 0 ? void 0 : _d.call(_c, `Acquired session "${this.session.sessionID}"`);
                          this.refresh(this.session.sessionID);
                      }
                      catch (e) {
                          if (e instanceof createSession.Error) {
                              const error = e.getActualType();
                              if (error.status === 400) {
                                  throw new Error(`Error creating session - (${error.status}) bad request: ${error.data.message}`);
                              }
                              if (error.status === 401) {
                                  throw new Error(`Error creating session - (${error.status}) unauthenticated: ${error.data.message}`);
                              }
                              if (error.status === 500) {
                                  throw new Error(`Error creating session - (${error.status}) server error: ${error.data.message}`);
                              }
                          }
                          throw e;
                      }
                  }
                  const hostname = this.getHostname(this.opts.__debug_port || WS_PORT);
                  if (!hostname) {
                      throw new Error("Cannot get session's hostname");
                  }
                  const protocol = this.opts.__debug_devEnv === 'local' ? 'ws' : 'wss';
                  const sessionURL = `${protocol}://${hostname}${WS_ROUTE}`;
                  this.rpc.onError(err => {
                      var _a, _b, _c, _d, _e;
                      // not warn, because this is somewhat expected behaviour during initialization
                      (_b = (_a = this.logger).debug) === null || _b === void 0 ? void 0 : _b.call(_a, `Error in WS session "${(_c = this.session) === null || _c === void 0 ? void 0 : _c.sessionID}": ${(_e = (_d = err.message) !== null && _d !== void 0 ? _d : err.code) !== null && _e !== void 0 ? _e : err.toString()}. Trying to reconnect...`);
                  });
                  let isFinished = false;
                  let resolveOpening;
                  let rejectOpening;
                  const openingPromise = new Promise((resolve, reject) => {
                      resolveOpening = () => {
                          if (isFinished)
                              return;
                          isFinished = true;
                          resolve();
                      };
                      rejectOpening = () => {
                          if (isFinished)
                              return;
                          isFinished = true;
                          reject();
                      };
                  });
                  this.rpc.onOpen(() => {
                      var _a, _b, _c;
                      (_b = (_a = this.logger).debug) === null || _b === void 0 ? void 0 : _b.call(_a, `Connected to session "${(_c = this.session) === null || _c === void 0 ? void 0 : _c.sessionID}"`);
                      resolveOpening === null || resolveOpening === void 0 ? void 0 : resolveOpening();
                  });
                  this.rpc.onClose(() => __awaiter(this, void 0, void 0, function* () {
                      var _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1;
                      (_p = (_o = this.logger).debug) === null || _p === void 0 ? void 0 : _p.call(_o, `Closing WS connection to session "${(_q = this.session) === null || _q === void 0 ? void 0 : _q.sessionID}"`);
                      if (this.isOpen) {
                          yield wait(WS_RECONNECT_INTERVAL);
                          (_s = (_r = this.logger).debug) === null || _s === void 0 ? void 0 : _s.call(_r, `Reconnecting to session "${(_t = this.session) === null || _t === void 0 ? void 0 : _t.sessionID}"`);
                          try {
                              // When the WS connection closes the subscribers in devbookd are removed.
                              // We want to delete the subscriber handlers here so there are no orphans.
                              this.subscribers = [];
                              yield this.rpc.connect(sessionURL);
                              (_v = (_u = this.logger).debug) === null || _v === void 0 ? void 0 : _v.call(_u, `Reconnected to session "${(_w = this.session) === null || _w === void 0 ? void 0 : _w.sessionID}"`);
                              // eslint-disable-next-line @typescript-eslint/no-explicit-any
                          }
                          catch (err) {
                              // not warn, because this is somewhat expected behaviour during initialization
                              (_y = (_x = this.logger).debug) === null || _y === void 0 ? void 0 : _y.call(_x, `Failed reconnecting to session "${(_z = this.session) === null || _z === void 0 ? void 0 : _z.sessionID}": ${(_1 = (_0 = err.message) !== null && _0 !== void 0 ? _0 : err.code) !== null && _1 !== void 0 ? _1 : err.toString()}`);
                          }
                      }
                      else {
                          rejectOpening === null || rejectOpening === void 0 ? void 0 : rejectOpening();
                      }
                  }));
                  this.rpc.onNotification.push(this.handleNotification.bind(this));
                  try {
                      (_f = (_e = this.logger).debug) === null || _f === void 0 ? void 0 : _f.call(_e, `Connection to session "${(_g = this.session) === null || _g === void 0 ? void 0 : _g.sessionID}"`);
                      yield this.rpc.connect(sessionURL);
                      // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  }
                  catch (err) {
                      // not warn, because this is somewhat expected behaviour during initialization
                      (_j = (_h = this.logger).debug) === null || _j === void 0 ? void 0 : _j.call(_h, `Error connecting to session "${(_k = this.session) === null || _k === void 0 ? void 0 : _k.sessionID}": ${(_m = (_l = err.message) !== null && _l !== void 0 ? _l : err.code) !== null && _m !== void 0 ? _m : err.toString()}`);
                  }
                  yield openingPromise;
                  return this;
              });
              return yield withTimeout(open, opts === null || opts === void 0 ? void 0 : opts.timeout)();
          });
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      call(service, method, params, opts) {
          var _a, _b;
          return __awaiter(this, void 0, void 0, function* () {
              (_b = (_a = this.logger).debug) === null || _b === void 0 ? void 0 : _b.call(_a, `Calling "${service}_${method}" with params:`, params);
              // Without the async function, the `this` context is lost.
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              const call = (method, params) => __awaiter(this, void 0, void 0, function* () { return yield this.rpc.call(method, params); });
              return yield withTimeout(call, opts === null || opts === void 0 ? void 0 : opts.timeout)(`${service}_${method}`, params);
          });
      }
      handleSubscriptions(...subs) {
          return __awaiter(this, void 0, void 0, function* () {
              const results = yield Promise.allSettled(subs);
              if (results.every(r => r.status === 'fulfilled')) {
                  return results.map(r => (r.status === 'fulfilled' ? r.value : undefined));
              }
              yield Promise.all(results
                  .filter(assertFulfilled)
                  .map(r => (r.value ? this.unsubscribe(r.value) : undefined)));
              throw new Error(formatSettledErrors(results));
          });
      }
      // eslint-disable-next-line @typescript-eslint/member-ordering
      unsubscribe(subID) {
          var _a, _b;
          return __awaiter(this, void 0, void 0, function* () {
              const subscription = this.subscribers.find(s => s.subID === subID);
              if (!subscription)
                  return;
              yield this.call(subscription.service, 'unsubscribe', [subscription.subID]);
              this.subscribers = this.subscribers.filter(s => s !== subscription);
              (_b = (_a = this.logger).debug) === null || _b === void 0 ? void 0 : _b.call(_a, `Unsubscribed '${subID}' from '${subscription.service}'`);
          });
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/member-ordering
      subscribe(service, handler, method, 
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ...params) {
          var _a, _b;
          return __awaiter(this, void 0, void 0, function* () {
              const subID = yield this.call(service, 'subscribe', [method, ...params]);
              if (typeof subID !== 'string') {
                  throw new Error(
                  // eslint-disable-next-line prettier/prettier
                  `Cannot subscribe to ${service}_${method}${params.length > 0 ? ' with params [' + params.join(', ') + ']' : ''}. Expected response should have been a subscription ID, instead we got ${JSON.stringify(subID)}`);
              }
              this.subscribers.push({
                  handler,
                  service,
                  subID,
              });
              (_b = (_a = this.logger).debug) === null || _b === void 0 ? void 0 : _b.call(_a, 
              // eslint-disable-next-line prettier/prettier
              `Subscribed to "${service}_${method}"${params.length > 0 ? ' with params [' + params.join(', ') + '] and' : ''} with id "${subID}"`);
              return subID;
          });
      }
      handleNotification(data) {
          var _a, _b;
          (_b = (_a = this.logger).debug) === null || _b === void 0 ? void 0 : _b.call(_a, 'Handling notification:', data);
          this.subscribers
              .filter(s => { var _a; return s.subID === ((_a = data.params) === null || _a === void 0 ? void 0 : _a.subscription); })
              .forEach(s => { var _a; return s.handler((_a = data.params) === null || _a === void 0 ? void 0 : _a.result); });
      }
      refresh(sessionID) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
          return __awaiter(this, void 0, void 0, function* () {
              (_b = (_a = this.logger).debug) === null || _b === void 0 ? void 0 : _b.call(_a, `Started refreshing session "${sessionID}"`);
              try {
                  // eslint-disable-next-line no-constant-condition
                  while (true) {
                      if (!this.isOpen) {
                          (_d = (_c = this.logger).debug) === null || _d === void 0 ? void 0 : _d.call(_c, `Cannot refresh session ${(_e = this.session) === null || _e === void 0 ? void 0 : _e.sessionID} - it was closed`);
                          return;
                      }
                      yield wait(SESSION_REFRESH_PERIOD);
                      try {
                          (_g = (_f = this.logger).debug) === null || _g === void 0 ? void 0 : _g.call(_f, `Refreshed session "${sessionID}"`);
                          yield refreshSession({
                              api_key: this.apiKey,
                              sessionID,
                          });
                      }
                      catch (e) {
                          if (e instanceof refreshSession.Error) {
                              const error = e.getActualType();
                              if (error.status === 404) {
                                  (_j = (_h = this.logger).warn) === null || _j === void 0 ? void 0 : _j.call(_h, `Error refreshing session - (${error.status}): ${error.data.message}`);
                                  return;
                              }
                              (_l = (_k = this.logger).warn) === null || _l === void 0 ? void 0 : _l.call(_k, `Refreshing session "${sessionID}" failed - (${error.status})`);
                          }
                      }
                  }
              }
              finally {
                  (_o = (_m = this.logger).debug) === null || _o === void 0 ? void 0 : _o.call(_m, `Stopped refreshing session "${sessionID}"`);
                  yield this.close();
              }
          });
      }
  }

  const terminalService = 'terminal';
  class TerminalOutput {
      constructor() {
          this._data = '';
      }
      get data() {
          return this._data;
      }
      addData(data) {
          this._data += data;
      }
  }
  /**
   * A terminal session running in the environment.
   */
  class Terminal {
      constructor(terminalID, session, triggerExit, finished, output) {
          this.terminalID = terminalID;
          this.session = session;
          this.triggerExit = triggerExit;
          this.finished = finished;
          this.output = output;
      }
      get data() {
          return this.output.data;
      }
      /**
       * Kills the terminal session.
       */
      kill() {
          return __awaiter(this, void 0, void 0, function* () {
              try {
                  // TODO: Change the "destroy" to "kill" in devbookd
                  yield this.session.call(terminalService, 'destroy', [this.terminalID]);
              }
              finally {
                  this.triggerExit();
                  yield this.finished;
              }
          });
      }
      /**
       * Sends data to the terminal standard input.
       *
       * @param data Data to send
       */
      sendData(data) {
          return __awaiter(this, void 0, void 0, function* () {
              yield this.session.call(terminalService, 'data', [this.terminalID, data]);
          });
      }
      /**
       * Resizes the terminal tty.
       *
       * @param cols Number of columns
       * @param rows Number of rows
       */
      resize({ cols, rows }) {
          return __awaiter(this, void 0, void 0, function* () {
              yield this.session.call(terminalService, 'resize', [this.terminalID, cols, rows]);
          });
      }
  }

  class Session extends SessionConnection {
      constructor(opts) {
          super(opts);
          this.onScanPorts = opts.onScanPorts;
          // Init Filesystem handler
          this.filesystem = {
              /**
               * List files in a directory.
               * @param path Path to a directory
               * @param opts Call options
               * @param {timeout} [opts.timeout] Timeout in milliseconds (default is 60 seconds)
               * @returns Array of files in a directory
               */
              list: (path, opts) => __awaiter(this, void 0, void 0, function* () {
                  return (yield this.call(filesystemService, 'list', [path], opts));
              }),
              /**
               * Reads the whole content of a file.
               * @param path Path to a file
               * @param opts Call options
               * @param {timeout} [opts.timeout] Timeout in milliseconds (default is 60 seconds)
               * @returns Content of a file
               */
              read: (path, opts) => __awaiter(this, void 0, void 0, function* () {
                  return (yield this.call(filesystemService, 'read', [path], opts));
              }),
              /**
               * Removes a file or a directory.
               * @param path Path to a file or a directory
               * @param opts Call options
               * @param {timeout} [opts.timeout] Timeout in milliseconds (default is 60 seconds)
               */
              remove: (path, opts) => __awaiter(this, void 0, void 0, function* () {
                  yield this.call(filesystemService, 'remove', [path], opts);
              }),
              /**
               * Writes content to a new file on path.
               * @param path Path to a new file. For example '/dirA/dirB/newFile.txt' when creating 'newFile.txt'
               * @param content Content to write to a new file
               * @param opts Call options
               * @param {timeout} [opts.timeout] Timeout in milliseconds (default is 60 seconds)
               */
              write: (path, content, opts) => __awaiter(this, void 0, void 0, function* () {
                  yield this.call(filesystemService, 'write', [path, content], opts);
              }),
              /**
               * Write array of bytes to a file.
               * This can be used when you cannot represent the data as an UTF-8 string.
               *
               * @param path path to a file
               * @param content byte array representing the content to write
               */
              writeBytes: (path, content) => __awaiter(this, void 0, void 0, function* () {
                  // We need to convert the byte array to base64 string without using browser or node specific APIs.
                  // This should be achieved by the node polyfills.
                  const base64Content = Buffer.from(content).toString('base64');
                  yield this.call(filesystemService, 'writeBase64', [path, base64Content]);
              }),
              /**
               * Reads the whole content of a file as an array of bytes.
               * @param path path to a file
               * @returns byte array representing the content of a file
               */
              readBytes: (path) => __awaiter(this, void 0, void 0, function* () {
                  const base64Content = (yield this.call(filesystemService, 'readBase64', [
                      path,
                  ]));
                  // We need to convert the byte array to base64 string without using browser or node specific APIs.
                  // This should be achieved by the node polyfills.
                  return Buffer.from(base64Content, 'base64');
              }),
              /**
               * Creates a new directory and all directories along the way if needed on the specified pth.
               * @param path Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
               * @param opts Call options
               * @param {timeout} [opts.timeout] Timeout in milliseconds (default is 60 seconds)
               */
              makeDir: (path, opts) => __awaiter(this, void 0, void 0, function* () {
                  yield this.call(filesystemService, 'makeDir', [path], opts);
              }),
              /**
               * Watches directory for filesystem events.
               * @param path Path to a directory that will be watched
               * @returns New watcher
               */
              watchDir: (path) => {
                  var _a, _b;
                  (_b = (_a = this.logger).debug) === null || _b === void 0 ? void 0 : _b.call(_a, `Watching directory "${path}"`);
                  const npath = normalizePath__default["default"](path);
                  return new FilesystemWatcher(this, npath);
              },
          };
          // Init Terminal handler
          this.terminal = {
              start: ({ onData, size, onExit, envVars, cmd, cwd = '', terminalID = id(12), timeout = undefined, }) => __awaiter(this, void 0, void 0, function* () {
                  const start = ({ onData, size, onExit, envVars, cmd, cwd = '', rootDir, terminalID = id(12), }) => __awaiter(this, void 0, void 0, function* () {
                      var _a, _b, _c, _d;
                      (_b = (_a = this.logger).debug) === null || _b === void 0 ? void 0 : _b.call(_a, `Starting terminal "${terminalID}"`);
                      if (!cwd && rootDir) {
                          (_d = (_c = this.logger).warn) === null || _d === void 0 ? void 0 : _d.call(_c, 'The rootDir parameter is deprecated, use cwd instead.');
                          cwd = rootDir;
                      }
                      if (!cwd && this.opts.cwd) {
                          cwd = this.opts.cwd;
                      }
                      const { promise: terminalExited, resolve: triggerExit } = createDeferredPromise();
                      const output = new TerminalOutput();
                      function handleData(data) {
                          output.addData(data);
                          onData === null || onData === void 0 ? void 0 : onData(data);
                      }
                      const [onDataSubID, onExitSubID] = yield this.handleSubscriptions(this.subscribe(terminalService, handleData, 'onData', terminalID), this.subscribe(terminalService, triggerExit, 'onExit', terminalID));
                      const { promise: unsubscribing, resolve: handleFinishUnsubscribing } = createDeferredPromise();
                      terminalExited.then(() => __awaiter(this, void 0, void 0, function* () {
                          var _e, _f, _g, _h;
                          const results = yield Promise.allSettled([
                              this.unsubscribe(onExitSubID),
                              this.unsubscribe(onDataSubID),
                          ]);
                          (_f = (_e = this.logger).debug) === null || _f === void 0 ? void 0 : _f.call(_e, `Terminal "${terminalID}" exited`);
                          const errMsg = formatSettledErrors(results);
                          if (errMsg) {
                              (_h = (_g = this.logger).error) === null || _h === void 0 ? void 0 : _h.call(_g, errMsg);
                          }
                          onExit === null || onExit === void 0 ? void 0 : onExit();
                          handleFinishUnsubscribing(output);
                      }));
                      try {
                          yield this.call(terminalService, 'start', [
                              terminalID,
                              size.cols,
                              size.rows,
                              // Handle optional args for old devbookd compatibility
                              ...(cmd !== undefined ? [envVars, cmd, cwd] : []),
                          ]);
                      }
                      catch (err) {
                          triggerExit();
                          yield unsubscribing;
                          throw err;
                      }
                      return new Terminal(terminalID, this, triggerExit, unsubscribing, output);
                  });
                  return yield withTimeout(start, timeout)({
                      onData,
                      size,
                      onExit,
                      envVars,
                      cmd,
                      cwd,
                      terminalID,
                  });
              }),
          };
          // Init Process handler
          this.process = {
              start: (opts) => __awaiter(this, void 0, void 0, function* () {
                  const start = ({ cmd, onStdout, onStderr, onExit, envVars = {}, cwd = '', rootDir, processID = id(12), }) => __awaiter(this, void 0, void 0, function* () {
                      var _j, _k, _l, _m;
                      if (!cwd && rootDir) {
                          (_k = (_j = this.logger).warn) === null || _k === void 0 ? void 0 : _k.call(_j, 'The rootDir parameter is deprecated, use cwd instead.');
                          cwd = rootDir;
                      }
                      if (!cwd && this.opts.cwd) {
                          cwd = this.opts.cwd;
                      }
                      if (!cmd)
                          throw new Error('cmd is required');
                      (_m = (_l = this.logger).debug) === null || _m === void 0 ? void 0 : _m.call(_l, `Starting process "${processID}", cmd: "${cmd}"`);
                      const { promise: processExited, resolve: triggerExit } = createDeferredPromise();
                      const output = new ProcessOutput();
                      function handleStdout(data) {
                          const message = new ProcessMessage(data.line, data.timestamp, false);
                          output.addStdout(message);
                          onStdout === null || onStdout === void 0 ? void 0 : onStdout(message);
                      }
                      function handleStderr(data) {
                          const message = new ProcessMessage(data.line, data.timestamp, true);
                          output.addStderr(message);
                          onStderr === null || onStderr === void 0 ? void 0 : onStderr(message);
                      }
                      const [onExitSubID, onStdoutSubID, onStderrSubID] = yield this.handleSubscriptions(this.subscribe(processService, triggerExit, 'onExit', processID), this.subscribe(processService, handleStdout, 'onStdout', processID), this.subscribe(processService, handleStderr, 'onStderr', processID));
                      const { promise: unsubscribing, resolve: handleFinishUnsubscribing } = createDeferredPromise();
                      processExited.then(() => __awaiter(this, void 0, void 0, function* () {
                          var _o, _p, _q, _r;
                          const results = yield Promise.allSettled([
                              this.unsubscribe(onExitSubID),
                              onStdoutSubID ? this.unsubscribe(onStdoutSubID) : undefined,
                              onStderrSubID ? this.unsubscribe(onStderrSubID) : undefined,
                          ]);
                          (_p = (_o = this.logger).debug) === null || _p === void 0 ? void 0 : _p.call(_o, `Process "${processID}" exited`);
                          const errMsg = formatSettledErrors(results);
                          if (errMsg) {
                              (_r = (_q = this.logger).error) === null || _r === void 0 ? void 0 : _r.call(_q, errMsg);
                          }
                          onExit === null || onExit === void 0 ? void 0 : onExit();
                          handleFinishUnsubscribing(output);
                      }));
                      try {
                          yield this.call(processService, 'start', [processID, cmd, envVars, cwd]);
                      }
                      catch (err) {
                          triggerExit();
                          yield unsubscribing;
                          throw err;
                      }
                      return new Process(processID, this, triggerExit, unsubscribing, output);
                  });
                  const timeout = opts.timeout;
                  return yield withTimeout(start, timeout)(opts);
              }),
          };
      }
      static create(opts) {
          return __awaiter(this, void 0, void 0, function* () {
              return new Session(opts).open({ timeout: opts === null || opts === void 0 ? void 0 : opts.timeout }).then((session) => __awaiter(this, void 0, void 0, function* () {
                  if (opts.cwd) {
                      console.log(`Custom cwd for Session set: "${opts.cwd}"`);
                      yield session.filesystem.makeDir(opts.cwd);
                  }
                  return session;
              }));
          });
      }
      open(opts) {
          const _super = Object.create(null, {
              open: { get: () => super.open }
          });
          return __awaiter(this, void 0, void 0, function* () {
              yield _super.open.call(this, opts);
              const portsHandler = this.onScanPorts
                  ? (ports) => { var _a; return (_a = this.onScanPorts) === null || _a === void 0 ? void 0 : _a.call(this, ports.map(p => ({ ip: p.Ip, port: p.Port, state: p.State }))); }
                  : undefined;
              yield this.handleSubscriptions(portsHandler
                  ? this.subscribe(codeSnippetService, portsHandler, 'scanOpenedPorts')
                  : undefined);
              return this;
          });
      }
  }

  var CodeRuntime;
  (function (CodeRuntime) {
      CodeRuntime["Node16"] = "Node16";
      CodeRuntime["Python3"] = "Python3";
  })(CodeRuntime || (CodeRuntime = {}));
  /**
   * Run code in a sandboxed cloud playground.
   * `runCode` wraps the `Session` class and provides a simple interface for running code in a sandboxed environment
   * without any need to manage lifecycle of the session.
   * `runCode` automatically loads the E2B API key from the `E2B_API_KEY` environment variable.
   *
   * @param runtime The runtime to use when running the code. Can be one of the following:
   * - "Node16"
   * - "Python3"
   *
   * **Let us know if you need support for other runtimes.**
   * @param code The code to run
   * @param opts Optional parameters to pass
   * @returns
   */
  function runCode(runtime, code, opts) {
      return __awaiter(this, void 0, void 0, function* () {
          let binary = '';
          let filepath = '';
          let envID = '';
          switch (runtime) {
              case CodeRuntime.Node16:
                  envID = 'Nodejs';
                  binary = 'node';
                  filepath = '/index.js';
                  break;
              case CodeRuntime.Python3:
                  envID = 'Python3';
                  binary = 'python3';
                  filepath = '/main.py';
                  break;
              default:
                  throw new Error(`The "${runtime}" runtime isn't supported. Please contact us (hello@e2b.dev) if you need support for this runtime`);
          }
          const session = yield Session.create({
              id: envID,
              apiKey: (opts === null || opts === void 0 ? void 0 : opts.apiKey) || process.env.E2B_API_KEY || '', // Session.create will throw an error if the API key is not provided so no need to check here
          });
          yield session.filesystem.write(filepath, code);
          const codeProc = yield session.process.start({
              cmd: `${binary} ${filepath}`,
          });
          const out = yield codeProc.finished;
          yield session.close();
          return {
              stdout: out.stdout,
              stderr: out.stderr,
          };
      });
  }

  exports.FilesystemWatcher = FilesystemWatcher;
  exports.Process = Process;
  exports.ProcessMessage = ProcessMessage;
  exports.ProcessOutput = ProcessOutput;
  exports.Session = Session;
  exports.Terminal = Terminal;
  exports.TerminalOutput = TerminalOutput;
  exports.api = client;
  exports.runCode = runCode;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.js.map
